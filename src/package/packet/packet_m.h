//
// Generated file, do not edit! Created by nedtool 4.6 from package/packet/packet.msg.
//

#ifndef _WSN_ENERGY_PACKET_M_H_
#define _WSN_ENERGY_PACKET_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include <ipAddress.h>
// }}


namespace wsn_energy {

/**
 * Enum generated from <tt>package/packet/packet.msg:18</tt> by nedtool.
 * <pre>
 * // ip packet type
 * enum IP_PACKET_NEXT_HEADER
 * {
 * 
 *     NEXT_HEADER_UDP = 0; // UDP  packet follows
 *     NEXT_HEADER_TCP = 1; // TCP  packet follows
 *     NEXT_HEADER_ICMP = 2; // ICMP packet follows
 * }
 * </pre>
 */
enum IP_PACKET_NEXT_HEADER {
    NEXT_HEADER_UDP = 0,
    NEXT_HEADER_TCP = 1,
    NEXT_HEADER_ICMP = 2
};

/**
 * Enum generated from <tt>package/packet/packet.msg:25</tt> by nedtool.
 * <pre>
 * // icmp packet type
 * enum ICMP_TYPE
 * {
 * 
 *     ICMP_RPL = 155; // ICMP RPL, 0x9b confirmed by IANA (1 octet)
 * }
 * </pre>
 */
enum ICMP_TYPE {
    ICMP_RPL = 155
};

/**
 * Enum generated from <tt>package/packet/packet.msg:30</tt> by nedtool.
 * <pre>
 * // rpl icmp packet type
 * enum ICMP_CODE
 * {
 * 
 *     RPL_DIO_CODE = 0;	// RPL DIO message, 0x00 confirmed by IANA (1 octet)
 *     RPL_DIS_CODE = 1;	// RPL DIS message, 0x01 confirmed by IANA (1 octet)
 * }
 * </pre>
 */
enum ICMP_CODE {
    RPL_DIO_CODE = 0,
    RPL_DIS_CODE = 1
};

/**
 * Class generated from <tt>package/packet/packet.msg:36</tt> by nedtool.
 * <pre>
 * // Packet
 * packet IpPacketInterface
 * {
 *     double time;  			// meta-data: timestamp
 *     int headerLength; 	// meta-data: header length, depends on specific format
 * }
 * </pre>
 */
class IpPacketInterface : public ::cPacket
{
  protected:
    double time_var;
    int headerLength_var;

  private:
    void copy(const IpPacketInterface& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacketInterface&);

  public:
    IpPacketInterface(const char *name=NULL, int kind=0);
    IpPacketInterface(const IpPacketInterface& other);
    virtual ~IpPacketInterface();
    IpPacketInterface& operator=(const IpPacketInterface& other);
    virtual IpPacketInterface *dup() const {return new IpPacketInterface(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual double getTime() const;
    virtual void setTime(double time);
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
};

inline void doPacking(cCommBuffer *b, IpPacketInterface& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacketInterface& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg:41</tt> by nedtool.
 * <pre>
 * packet IpPacketStandard extends IpPacketInterface
 * {
 *     // 		standard (non-compress) = 40 octets RFC 2460
 *     headerLength = 40;
 * 
 * //     4 bits version
 * //     8 bits traffic class
 * //     20 bits flow label
 * //     2 octets payload length
 * //     1 octets next header
 * //     1 octets hop limit
 * //     16 octets IPv6 source
 * //     16 octets IPv6 destination
 * 
 *     int version;
 *     int trafficClass;
 *     int flowLabel;
 *     int payloadLength;
 *     int nextHeader; // type: ICMP, UDP, TCP
 *     int hopLimit;
 *     IpAddress sourceIpAddressV6;
 *     IpAddress destinationIpAddressV6;
 * 
 *     int sourceIpAddress;
 *     int destinationIpAddress;
 * }
 * </pre>
 */
class IpPacketStandard : public ::wsn_energy::IpPacketInterface
{
  protected:
    int version_var;
    int trafficClass_var;
    int flowLabel_var;
    int payloadLength_var;
    int nextHeader_var;
    int hopLimit_var;
    IpAddress sourceIpAddressV6_var;
    IpAddress destinationIpAddressV6_var;
    int sourceIpAddress_var;
    int destinationIpAddress_var;

  private:
    void copy(const IpPacketStandard& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacketStandard&);

  public:
    IpPacketStandard(const char *name=NULL, int kind=0);
    IpPacketStandard(const IpPacketStandard& other);
    virtual ~IpPacketStandard();
    IpPacketStandard& operator=(const IpPacketStandard& other);
    virtual IpPacketStandard *dup() const {return new IpPacketStandard(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual int getTrafficClass() const;
    virtual void setTrafficClass(int trafficClass);
    virtual int getFlowLabel() const;
    virtual void setFlowLabel(int flowLabel);
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
    virtual int getNextHeader() const;
    virtual void setNextHeader(int nextHeader);
    virtual int getHopLimit() const;
    virtual void setHopLimit(int hopLimit);
    virtual IpAddress& getSourceIpAddressV6();
    virtual const IpAddress& getSourceIpAddressV6() const {return const_cast<IpPacketStandard*>(this)->getSourceIpAddressV6();}
    virtual void setSourceIpAddressV6(const IpAddress& sourceIpAddressV6);
    virtual IpAddress& getDestinationIpAddressV6();
    virtual const IpAddress& getDestinationIpAddressV6() const {return const_cast<IpPacketStandard*>(this)->getDestinationIpAddressV6();}
    virtual void setDestinationIpAddressV6(const IpAddress& destinationIpAddressV6);
    virtual int getSourceIpAddress() const;
    virtual void setSourceIpAddress(int sourceIpAddress);
    virtual int getDestinationIpAddress() const;
    virtual void setDestinationIpAddress(int destinationIpAddress);
};

inline void doPacking(cCommBuffer *b, IpPacketStandard& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacketStandard& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg:67</tt> by nedtool.
 * <pre>
 * packet IpPacketCompressed extends IpPacketInterface
 * {
 *     headerLength = 2;
 * 
 * //	The "HC1 encoding" is shown below (starting with bit 0 and ending at
 * //  bit 7):
 * //
 * //		PI = prefix carried in-line non-compressed		
 * //		PC = prefix compressed
 * //		II = interface identifier in-line
 * //		IC = interface identifier compressed
 * //		
 * //  IPv6 source address (bits 0 and 1):
 * //  	00:  PI, II
 * //  	01:  PI, IC
 * //  	10:  PC, II
 * //  	11:  PC, IC
 * //
 * //  IPv6 destination address (bits 2 and 3):
 * //  	00:  PI, II
 * //  	01:  PI, IC
 * //  	10:  PC, II
 * //  	11:  PC, IC
 * //
 * //  Traffic Class and Flow Label (bit 4):
 * //  	0: not compressed, full 8 bits for Traffic Class and 20 bits
 * //     		for Flow Label are sent
 * //		1: Traffic Class and Flow Label are zero
 * //
 * //  Next Header (bits 5 and 6):
 * //  	00:  not compressed, full 8 bits are sent
 * //  	01:  UDP
 * //  	10:  ICMP
 * //  	11:  TCP
 * //
 * //  HC2 encoding(bit 7):
 * //  	0: No more header compression bits
 * //  	1: HC1 encoding immediately followed by more header compression
 * //     		bits per HC2 encoding format.  Bits 5 and 6 determine which
 * //     		of the possible HC2 encodings apply (e.g., UDP, ICMP or TCP
 * //     		encodings).
 * 
 *     int sourceIpAddress; 			// 2 bits + 0 bit compressed/ 128 bits non-compressed
 *     int destinationIpAddress; 		// 2 bits + 0 bit compressed/ 128 bits non-compressed
 *     int trafficClassAndFlowLabel; 	// 1 bit + 0 bit compressed/  28 bits non-compressed
 *     int nextHeader;					// 2 bits + 0 bit compressed/ 8 bits non-compressed
 *     int hc2encoding;				// 1 bit (determines whether any header compression bits)
 * 
 *     int hopLimit; 					// 1 octet NEVER COMPRESSED
 * 
 *     int metaHopLimit;			  // in-line: hop limit
 *     IpAddress metaSourceIpAddressV6;	    // meta-data: source Ip address
 *     IpAddress metaDestinationIpAddressV6; // meta-data: destination ip address
 * 
 *     int metaSourceIpAddress;	    // meta
 *     int metaDestinationIpAddress; // meta
 * }
 * </pre>
 */
class IpPacketCompressed : public ::wsn_energy::IpPacketInterface
{
  protected:
    int sourceIpAddress_var;
    int destinationIpAddress_var;
    int trafficClassAndFlowLabel_var;
    int nextHeader_var;
    int hc2encoding_var;
    int hopLimit_var;
    int metaHopLimit_var;
    IpAddress metaSourceIpAddressV6_var;
    IpAddress metaDestinationIpAddressV6_var;
    int metaSourceIpAddress_var;
    int metaDestinationIpAddress_var;

  private:
    void copy(const IpPacketCompressed& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacketCompressed&);

  public:
    IpPacketCompressed(const char *name=NULL, int kind=0);
    IpPacketCompressed(const IpPacketCompressed& other);
    virtual ~IpPacketCompressed();
    IpPacketCompressed& operator=(const IpPacketCompressed& other);
    virtual IpPacketCompressed *dup() const {return new IpPacketCompressed(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSourceIpAddress() const;
    virtual void setSourceIpAddress(int sourceIpAddress);
    virtual int getDestinationIpAddress() const;
    virtual void setDestinationIpAddress(int destinationIpAddress);
    virtual int getTrafficClassAndFlowLabel() const;
    virtual void setTrafficClassAndFlowLabel(int trafficClassAndFlowLabel);
    virtual int getNextHeader() const;
    virtual void setNextHeader(int nextHeader);
    virtual int getHc2encoding() const;
    virtual void setHc2encoding(int hc2encoding);
    virtual int getHopLimit() const;
    virtual void setHopLimit(int hopLimit);
    virtual int getMetaHopLimit() const;
    virtual void setMetaHopLimit(int metaHopLimit);
    virtual IpAddress& getMetaSourceIpAddressV6();
    virtual const IpAddress& getMetaSourceIpAddressV6() const {return const_cast<IpPacketCompressed*>(this)->getMetaSourceIpAddressV6();}
    virtual void setMetaSourceIpAddressV6(const IpAddress& metaSourceIpAddressV6);
    virtual IpAddress& getMetaDestinationIpAddressV6();
    virtual const IpAddress& getMetaDestinationIpAddressV6() const {return const_cast<IpPacketCompressed*>(this)->getMetaDestinationIpAddressV6();}
    virtual void setMetaDestinationIpAddressV6(const IpAddress& metaDestinationIpAddressV6);
    virtual int getMetaSourceIpAddress() const;
    virtual void setMetaSourceIpAddress(int metaSourceIpAddress);
    virtual int getMetaDestinationIpAddress() const;
    virtual void setMetaDestinationIpAddress(int metaDestinationIpAddress);
};

inline void doPacking(cCommBuffer *b, IpPacketCompressed& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacketCompressed& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg:135</tt> by nedtool.
 * <pre>
 * // ICMP Packet
 * packet IcmpPacket
 * {
 *     // standard (non-compress) = 8 octets
 *     int headerLength = 8;
 * 
 * 	// 1 octets of type
 * 	// 1 octets of code
 * 	// 2 octets of checksum
 * 	// 2 octets of other message specific information
 * 
 *     int type; // RPL ICMPv6
 *     int code; // DIO, DIS
 *     int checksum;
 *     int others;
 * }
 * </pre>
 */
class IcmpPacket : public ::cPacket
{
  protected:
    int headerLength_var;
    int type_var;
    int code_var;
    int checksum_var;
    int others_var;

  private:
    void copy(const IcmpPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IcmpPacket&);

  public:
    IcmpPacket(const char *name=NULL, int kind=0);
    IcmpPacket(const IcmpPacket& other);
    virtual ~IcmpPacket();
    IcmpPacket& operator=(const IcmpPacket& other);
    virtual IcmpPacket *dup() const {return new IcmpPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
    virtual int getType() const;
    virtual void setType(int type);
    virtual int getCode() const;
    virtual void setCode(int code);
    virtual int getChecksum() const;
    virtual void setChecksum(int checksum);
    virtual int getOthers() const;
    virtual void setOthers(int others);
};

inline void doPacking(cCommBuffer *b, IcmpPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IcmpPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg:150</tt> by nedtool.
 * <pre>
 * packet DIO
 * {
 *     int senderID; // meta-data: sender IP
 *     int payloadLength = 24; // meta-data: length of DIO 
 * 
 *     int instanceID;
 *     int version; // version
 *     unsigned long rank; // rank 
 *     bool grounded;
 *     bool o;
 *     int modeOfOperation;
 *     int preference;
 *     int dstn;
 *     int flags;
 *     int reserved;
 *     int dodagID; // DODAGID
 * }
 * </pre>
 */
class DIO : public ::cPacket
{
  protected:
    int senderID_var;
    int payloadLength_var;
    int instanceID_var;
    int version_var;
    unsigned long rank_var;
    bool grounded_var;
    bool o_var;
    int modeOfOperation_var;
    int preference_var;
    int dstn_var;
    int flags_var;
    int reserved_var;
    int dodagID_var;

  private:
    void copy(const DIO& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIO&);

  public:
    DIO(const char *name=NULL, int kind=0);
    DIO(const DIO& other);
    virtual ~DIO();
    DIO& operator=(const DIO& other);
    virtual DIO *dup() const {return new DIO(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSenderID() const;
    virtual void setSenderID(int senderID);
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
    virtual int getInstanceID() const;
    virtual void setInstanceID(int instanceID);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual unsigned long getRank() const;
    virtual void setRank(unsigned long rank);
    virtual bool getGrounded() const;
    virtual void setGrounded(bool grounded);
    virtual bool getO() const;
    virtual void setO(bool o);
    virtual int getModeOfOperation() const;
    virtual void setModeOfOperation(int modeOfOperation);
    virtual int getPreference() const;
    virtual void setPreference(int preference);
    virtual int getDstn() const;
    virtual void setDstn(int dstn);
    virtual int getFlags() const;
    virtual void setFlags(int flags);
    virtual int getReserved() const;
    virtual void setReserved(int reserved);
    virtual int getDodagID() const;
    virtual void setDodagID(int dodagID);
};

inline void doPacking(cCommBuffer *b, DIO& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIO& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg:167</tt> by nedtool.
 * <pre>
 * packet DIS
 * {
 *     int payloadLength = 2; // meta-data: length of DIO
 * 
 * 	// 1 octet flag
 * 	// 1 octet reserved
 * 
 *     int flag;
 *     int reserved;
 * }
 * </pre>
 */
class DIS : public ::cPacket
{
  protected:
    int payloadLength_var;
    int flag_var;
    int reserved_var;

  private:
    void copy(const DIS& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIS&);

  public:
    DIS(const char *name=NULL, int kind=0);
    DIS(const DIS& other);
    virtual ~DIS();
    DIS& operator=(const DIS& other);
    virtual DIS *dup() const {return new DIS(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
    virtual int getFlag() const;
    virtual void setFlag(int flag);
    virtual int getReserved() const;
    virtual void setReserved(int reserved);
};

inline void doPacking(cCommBuffer *b, DIS& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIS& obj) {obj.parsimUnpack(b);}

} // namespace wsn_energy

#endif // ifndef _WSN_ENERGY_PACKET_M_H_

