//
// Generated file, do not edit! Created by nedtool 4.6 from package/frame/frame.msg.
//

#ifndef _WSN_ENERGY_FRAME_M_H_
#define _WSN_ENERGY_FRAME_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include <ipAddress.h>
#include <macAddress.h>
// }}


namespace wsn_energy {

/**
 * Enum generated from <tt>package/frame/frame.msg:19</tt> by nedtool.
 * <pre>
 * enum FRAME_TYPE
 * {
 * 
 *     FRAME_BEACON = 0; // frame beacon
 *     FRAME_COMMAND = 1; // frame command
 *     FRAME_DATA = 2; // frame data
 *     FRAME_ACK = 3; // frame ack
 * }
 * </pre>
 */
enum FRAME_TYPE {
    FRAME_BEACON = 0,
    FRAME_COMMAND = 1,
    FRAME_DATA = 2,
    FRAME_ACK = 3
};

/**
 * Class generated from <tt>package/frame/frame.msg:27</tt> by nedtool.
 * <pre>
 * // Frame
 * packet Frame
 * {
 *     int numberTransmission = 0; // meta-data: number transmission
 *     int headerLength; 			// meta-data: determined upon frame creation
 * 
 *     // MAC protocol data unit (MPDU) = PHY service data unit (PSDU)
 * 
 *     // Frame Control Field 2 octets
 *     int frameType;        		    //  3 bit. Frame type field, see 802.15.4
 *     int securityEnabled;  		    //  1 bit. True if security is used in this frame
 *     int framePending;     			//  1 bit. True if sender has more data to send (in case of IP fragmentation)
 *     bool ackRequired;      			//  1 bit. Is an ack frame required?
 *     bool panIdCompression; 			//  1 bit. Is this a compressed header?
 *     int reserved; 		     	    //  3 bit. Unused bits
 *     int destinationAddressMode;     //  2 bit. Destination address mode, see 802.15.4
 *     int frameVersion;     		    //  2 bit. 802.15.4 frame version
 *     int sourceAddressMode;          //  2 bit. Source address mode, see 802.15.4
 * 
 *     // Frame Check Sequence 2 octets FCS = MAC Footer MFR
 *     uint16_t frameCheckSequence;
 * }
 * </pre>
 */
class Frame : public ::cPacket
{
  protected:
    int numberTransmission_var;
    int headerLength_var;
    int frameType_var;
    int securityEnabled_var;
    int framePending_var;
    bool ackRequired_var;
    bool panIdCompression_var;
    int reserved_var;
    int destinationAddressMode_var;
    int frameVersion_var;
    int sourceAddressMode_var;
    uint16_t frameCheckSequence_var;

  private:
    void copy(const Frame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Frame&);

  public:
    Frame(const char *name=NULL, int kind=0);
    Frame(const Frame& other);
    virtual ~Frame();
    Frame& operator=(const Frame& other);
    virtual Frame *dup() const {return new Frame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNumberTransmission() const;
    virtual void setNumberTransmission(int numberTransmission);
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
    virtual int getFrameType() const;
    virtual void setFrameType(int frameType);
    virtual int getSecurityEnabled() const;
    virtual void setSecurityEnabled(int securityEnabled);
    virtual int getFramePending() const;
    virtual void setFramePending(int framePending);
    virtual bool getAckRequired() const;
    virtual void setAckRequired(bool ackRequired);
    virtual bool getPanIdCompression() const;
    virtual void setPanIdCompression(bool panIdCompression);
    virtual int getReserved() const;
    virtual void setReserved(int reserved);
    virtual int getDestinationAddressMode() const;
    virtual void setDestinationAddressMode(int destinationAddressMode);
    virtual int getFrameVersion() const;
    virtual void setFrameVersion(int frameVersion);
    virtual int getSourceAddressMode() const;
    virtual void setSourceAddressMode(int sourceAddressMode);
    virtual uint16_t getFrameCheckSequence() const;
    virtual void setFrameCheckSequence(uint16_t frameCheckSequence);
};

inline void doPacking(cCommBuffer *b, Frame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Frame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/frame/frame.msg:49</tt> by nedtool.
 * <pre>
 * // Data frame
 * packet FrameDataStandard extends Frame
 * {
 *     // 	standard (non-compress) = 25 octets RFC 2460
 *     headerLength = 25; // meta-data: length of this frame    
 * 
 *     int dataSequenceNumber;	// 1 octet. Sequence number
 * 
 *     uint16_t sourcePanID;	  				// 0/2   octets PANID - hard coded
 *     uint16_t destinationPanID; 				// 0/2   octets PANID - hard coded
 *     MacAddress sourceMacAddressEUI64; 		// 0/2/8 octets link-layer address address
 *     MacAddress destinationMacAddressEUI64;  // 0/2/8 octets link-layer addressaddress
 * 
 *     int sourceMacAddress; 		// meta
 *     int destinationMacAddress;  // meta
 * }
 * </pre>
 */
class FrameDataStandard : public ::wsn_energy::Frame
{
  protected:
    int dataSequenceNumber_var;
    uint16_t sourcePanID_var;
    uint16_t destinationPanID_var;
    MacAddress sourceMacAddressEUI64_var;
    MacAddress destinationMacAddressEUI64_var;
    int sourceMacAddress_var;
    int destinationMacAddress_var;

  private:
    void copy(const FrameDataStandard& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FrameDataStandard&);

  public:
    FrameDataStandard(const char *name=NULL, int kind=0);
    FrameDataStandard(const FrameDataStandard& other);
    virtual ~FrameDataStandard();
    FrameDataStandard& operator=(const FrameDataStandard& other);
    virtual FrameDataStandard *dup() const {return new FrameDataStandard(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getDataSequenceNumber() const;
    virtual void setDataSequenceNumber(int dataSequenceNumber);
    virtual uint16_t getSourcePanID() const;
    virtual void setSourcePanID(uint16_t sourcePanID);
    virtual uint16_t getDestinationPanID() const;
    virtual void setDestinationPanID(uint16_t destinationPanID);
    virtual MacAddress& getSourceMacAddressEUI64();
    virtual const MacAddress& getSourceMacAddressEUI64() const {return const_cast<FrameDataStandard*>(this)->getSourceMacAddressEUI64();}
    virtual void setSourceMacAddressEUI64(const MacAddress& sourceMacAddressEUI64);
    virtual MacAddress& getDestinationMacAddressEUI64();
    virtual const MacAddress& getDestinationMacAddressEUI64() const {return const_cast<FrameDataStandard*>(this)->getDestinationMacAddressEUI64();}
    virtual void setDestinationMacAddressEUI64(const MacAddress& destinationMacAddressEUI64);
    virtual int getSourceMacAddress() const;
    virtual void setSourceMacAddress(int sourceMacAddress);
    virtual int getDestinationMacAddress() const;
    virtual void setDestinationMacAddress(int destinationMacAddress);
};

inline void doPacking(cCommBuffer *b, FrameDataStandard& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FrameDataStandard& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/frame/frame.msg:64</tt> by nedtool.
 * <pre>
 * packet FrameDataCompressed extends Frame
 * {
 *     //	 compressed = 8 octets + normal header 25 octets
 *     int headerLength = 32;
 * 
 * // 		order of header (sicslowmac)
 * //		5 octets: Mesh Addressing Header (short address)
 * //      2 octet:  Broadcast Header 
 * //      1 octet:  Fragmentation Header (not implemented yet)
 * // 		Header Compressed Header (dispatch)
 * //
 * // 		4 octets minimum Mesh header 4944
 * //
 * // 		0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * //      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //      |1 0|O|F|HopsLft| originator address, final address
 * //      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //
 * //	O: This 1-bit field SHALL be zero if the Originator Address is an
 * //      IEEE extended 64 bit address (EUI-64), or 1 if it is a short 16-
 * //      bit addresses.
 * //
 * //  F: This 1-bit field SHALL be zero if the Final Destination Address is
 * //      an IEEE extended 64 bit address (EUI-64), or 1 if it is a short
 * //      16-bit addresses.
 * //
 * //  Hops Left:  This 4-bit field SHALL be decremented by each forwarding
 * //      node before sending this packet towards its next hop.  The packet
 * //      is not forwarded any further if Hops Left is decremented to 0.
 * //      The value 0xF is reserved and signifies an 8-bit Deep Hops Left
 * //      field immediately following, and allows a source node to specify a
 * //      hop limit greater than 14 hops.
 * //
 * // 	Originator Address:  This is the link-layer address of the
 * //      Originator.
 * //
 * //  Final Destination Address:  This is the link-layer address of the
 * //      Final Destination.
 * //
 * //   Note that the 'O' and 'F' bits allow for a mix of 16 and 64-bit
 * //   addresses.  This is useful at least to allow for mesh layer
 * //   "broadcast", as 802.15.4 broadcast addresses are defined as 16-bit
 * //   short addresses.
 * //
 * //  2 octets Broadcast Header 
 * //                           1
 * //       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
 * //      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //      |0|1|LOWPAN_BC0 |Sequence Number|
 * //      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //
 * //	1 octet dispatch (pattern - header)
 * //		  | 00  xxxxxx | NALP       - Not a LoWPAN frame               
 * //        | 01  000001 | IPv6       - uncompressed IPv6 Addresses      <-- ATTENTION
 * //        | 01  000010 | LOWPAN_HC1 - LOWPAN_HC1 compressed IPv6       <-- ATTENTION
 * //        |   ...      | reserved   - Reserved for future use          
 * //        | 01  010000 | LOWPAN_BC0 - LOWPAN_BC0 broadcast   <-- ATTENTION          
 * //        |   ...      | reserved   - Reserved for future use          
 * //        | 01  111111 | ESC        - Additional Dispatch octet follows 
 * 
 *     int codeBit;						// 2 bits
 *     bool isOrignatorCompressed;			// 1 bit
 *     bool isFinalDestinationCompressed;	// 1 bit
 *     int hopLeft;						// 4 bits
 * 
 *     int hcDispatch;						// 1 octet
 * 
 *     int broadcastHeader;				// 1 octet
 *     int fragmentationHeader;			// 1 octet
 * 
 *     MacAddress orginatorAddressEUI64; 				// 2/8 octects
 *     MacAddress finalDestinationMacAddressEUI64;  	// 2/8 octects
 * 
 *     // normal MAC header
 *     int dataSequenceNumber;		// 1 octet. Sequence number
 * 
 *     int sourcePanID;	  					// 0/2   octets PANID - hard-coded
 *     int destinationPanID; 					// 0/2   octets PANID - hard-coded
 *     MacAddress sourceMacAddressEUI64; 		// 0/2/8 octets link-layer address address
 *     MacAddress destinationMacAddressEUI64;  // 0/2/8 octets link-layer addressaddress
 * 
 *     int orginatorMacAddress; 			// meta
 *     int finalDestinationMacAddress;		// meta
 *     int sourceMacAddress; 		// meta
 *     int destinationMacAddress;  // meta
 * }
 * </pre>
 */
class FrameDataCompressed : public ::wsn_energy::Frame
{
  protected:
    int headerLength_var;
    int codeBit_var;
    bool isOrignatorCompressed_var;
    bool isFinalDestinationCompressed_var;
    int hopLeft_var;
    int hcDispatch_var;
    int broadcastHeader_var;
    int fragmentationHeader_var;
    MacAddress orginatorAddressEUI64_var;
    MacAddress finalDestinationMacAddressEUI64_var;
    int dataSequenceNumber_var;
    int sourcePanID_var;
    int destinationPanID_var;
    MacAddress sourceMacAddressEUI64_var;
    MacAddress destinationMacAddressEUI64_var;
    int orginatorMacAddress_var;
    int finalDestinationMacAddress_var;
    int sourceMacAddress_var;
    int destinationMacAddress_var;

  private:
    void copy(const FrameDataCompressed& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FrameDataCompressed&);

  public:
    FrameDataCompressed(const char *name=NULL, int kind=0);
    FrameDataCompressed(const FrameDataCompressed& other);
    virtual ~FrameDataCompressed();
    FrameDataCompressed& operator=(const FrameDataCompressed& other);
    virtual FrameDataCompressed *dup() const {return new FrameDataCompressed(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
    virtual int getCodeBit() const;
    virtual void setCodeBit(int codeBit);
    virtual bool getIsOrignatorCompressed() const;
    virtual void setIsOrignatorCompressed(bool isOrignatorCompressed);
    virtual bool getIsFinalDestinationCompressed() const;
    virtual void setIsFinalDestinationCompressed(bool isFinalDestinationCompressed);
    virtual int getHopLeft() const;
    virtual void setHopLeft(int hopLeft);
    virtual int getHcDispatch() const;
    virtual void setHcDispatch(int hcDispatch);
    virtual int getBroadcastHeader() const;
    virtual void setBroadcastHeader(int broadcastHeader);
    virtual int getFragmentationHeader() const;
    virtual void setFragmentationHeader(int fragmentationHeader);
    virtual MacAddress& getOrginatorAddressEUI64();
    virtual const MacAddress& getOrginatorAddressEUI64() const {return const_cast<FrameDataCompressed*>(this)->getOrginatorAddressEUI64();}
    virtual void setOrginatorAddressEUI64(const MacAddress& orginatorAddressEUI64);
    virtual MacAddress& getFinalDestinationMacAddressEUI64();
    virtual const MacAddress& getFinalDestinationMacAddressEUI64() const {return const_cast<FrameDataCompressed*>(this)->getFinalDestinationMacAddressEUI64();}
    virtual void setFinalDestinationMacAddressEUI64(const MacAddress& finalDestinationMacAddressEUI64);
    virtual int getDataSequenceNumber() const;
    virtual void setDataSequenceNumber(int dataSequenceNumber);
    virtual int getSourcePanID() const;
    virtual void setSourcePanID(int sourcePanID);
    virtual int getDestinationPanID() const;
    virtual void setDestinationPanID(int destinationPanID);
    virtual MacAddress& getSourceMacAddressEUI64();
    virtual const MacAddress& getSourceMacAddressEUI64() const {return const_cast<FrameDataCompressed*>(this)->getSourceMacAddressEUI64();}
    virtual void setSourceMacAddressEUI64(const MacAddress& sourceMacAddressEUI64);
    virtual MacAddress& getDestinationMacAddressEUI64();
    virtual const MacAddress& getDestinationMacAddressEUI64() const {return const_cast<FrameDataCompressed*>(this)->getDestinationMacAddressEUI64();}
    virtual void setDestinationMacAddressEUI64(const MacAddress& destinationMacAddressEUI64);
    virtual int getOrginatorMacAddress() const;
    virtual void setOrginatorMacAddress(int orginatorMacAddress);
    virtual int getFinalDestinationMacAddress() const;
    virtual void setFinalDestinationMacAddress(int finalDestinationMacAddress);
    virtual int getSourceMacAddress() const;
    virtual void setSourceMacAddress(int sourceMacAddress);
    virtual int getDestinationMacAddress() const;
    virtual void setDestinationMacAddress(int destinationMacAddress);
};

inline void doPacking(cCommBuffer *b, FrameDataCompressed& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FrameDataCompressed& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/frame/frame.msg:151</tt> by nedtool.
 * <pre>
 * // ACK Frame
 * packet FrameACK extends Frame
 * {
 *     headerLength = 5; // empty
 * 
 *     int dataSequenceNumber;          	// 8 bit. Sequence number
 * }
 * </pre>
 */
class FrameACK : public ::wsn_energy::Frame
{
  protected:
    int dataSequenceNumber_var;

  private:
    void copy(const FrameACK& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FrameACK&);

  public:
    FrameACK(const char *name=NULL, int kind=0);
    FrameACK(const FrameACK& other);
    virtual ~FrameACK();
    FrameACK& operator=(const FrameACK& other);
    virtual FrameACK *dup() const {return new FrameACK(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getDataSequenceNumber() const;
    virtual void setDataSequenceNumber(int dataSequenceNumber);
};

inline void doPacking(cCommBuffer *b, FrameACK& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FrameACK& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/frame/frame.msg:158</tt> by nedtool.
 * <pre>
 * // In case of synchronize, and neighbor discovery (unslotted CSMA/CA)
 * packet FrameBeacon extends Frame
 * {
 *     headerLength = 26;
 * 
 *     int beaconSequenceNumber;	// 1 octet. Sequence number
 * 
 *     int sourcePanID;	  		// 0/2   octets PANID
 *     int destinationPanID; 		// 0/2   octets PANID
 *     int sourceMacAddress; 		// 0/2/8 octets link-layer address address
 *     int destinationMacAddress;  // 0/2/8 octets link-layer addressaddress
 * 
 *     // 2 octets Superframe specification
 *     int beaconOrder;			// 4 bit
 *     int superFrameOrder;		// 4 bit
 *     int finalCAPslot;			// 4 bit
 *     int batteryLifeExtension;	// 1 bit
 *     int reserved;				// 1 bit
 *     int PANcoordinator;			// 1 bit
 *     int associationPermit;		// 1 bit
 * 
 * 	// variable GTS
 * 	// variable pendingAddressFields
 * 	// variable beaconPayload
 * }
 * </pre>
 */
class FrameBeacon : public ::wsn_energy::Frame
{
  protected:
    int beaconSequenceNumber_var;
    int sourcePanID_var;
    int destinationPanID_var;
    int sourceMacAddress_var;
    int destinationMacAddress_var;
    int beaconOrder_var;
    int superFrameOrder_var;
    int finalCAPslot_var;
    int batteryLifeExtension_var;
    int reserved_var;
    int PANcoordinator_var;
    int associationPermit_var;

  private:
    void copy(const FrameBeacon& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FrameBeacon&);

  public:
    FrameBeacon(const char *name=NULL, int kind=0);
    FrameBeacon(const FrameBeacon& other);
    virtual ~FrameBeacon();
    FrameBeacon& operator=(const FrameBeacon& other);
    virtual FrameBeacon *dup() const {return new FrameBeacon(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getBeaconSequenceNumber() const;
    virtual void setBeaconSequenceNumber(int beaconSequenceNumber);
    virtual int getSourcePanID() const;
    virtual void setSourcePanID(int sourcePanID);
    virtual int getDestinationPanID() const;
    virtual void setDestinationPanID(int destinationPanID);
    virtual int getSourceMacAddress() const;
    virtual void setSourceMacAddress(int sourceMacAddress);
    virtual int getDestinationMacAddress() const;
    virtual void setDestinationMacAddress(int destinationMacAddress);
    virtual int getBeaconOrder() const;
    virtual void setBeaconOrder(int beaconOrder);
    virtual int getSuperFrameOrder() const;
    virtual void setSuperFrameOrder(int superFrameOrder);
    virtual int getFinalCAPslot() const;
    virtual void setFinalCAPslot(int finalCAPslot);
    virtual int getBatteryLifeExtension() const;
    virtual void setBatteryLifeExtension(int batteryLifeExtension);
    virtual int getReserved() const;
    virtual void setReserved(int reserved);
    virtual int getPANcoordinator() const;
    virtual void setPANcoordinator(int PANcoordinator);
    virtual int getAssociationPermit() const;
    virtual void setAssociationPermit(int associationPermit);
};

inline void doPacking(cCommBuffer *b, FrameBeacon& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FrameBeacon& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/frame/frame.msg:183</tt> by nedtool.
 * <pre>
 * // In case of synchronize, and neighbor discovery (unslotted CSMA/CA)
 * packet FrameCommand extends Frame
 * {
 *     headerLength = 25;
 * 
 *     int dataSequenceNumber;	// 8 bit. Sequence number
 * 
 *     int sourcePanID;	  		// 0/2   octets PANID
 *     int destinationPanID; 		// 0/2   octets PANID
 *     int sourceMacAddress; 		// 0/2/8 octets link-layer address address
 *     int destinationMacAddress;  // 0/2/8 octets link-layer addressaddress
 * 
 *     // 1 octets Command type
 *     int commandType; // 8 bit
 * 
 * 	//	Association request
 * 	//	Association response
 * 	//	Disassociation notification
 * 	//	Data request
 * 	//	PAN ID conflict notification
 * 	//	Orphan Notification
 * 	//	Beacon request
 * 	//	Coordinator realignment
 * 	//	GTS request
 * 
 * 	// variable command payload
 * }
 * </pre>
 */
class FrameCommand : public ::wsn_energy::Frame
{
  protected:
    int dataSequenceNumber_var;
    int sourcePanID_var;
    int destinationPanID_var;
    int sourceMacAddress_var;
    int destinationMacAddress_var;
    int commandType_var;

  private:
    void copy(const FrameCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FrameCommand&);

  public:
    FrameCommand(const char *name=NULL, int kind=0);
    FrameCommand(const FrameCommand& other);
    virtual ~FrameCommand();
    FrameCommand& operator=(const FrameCommand& other);
    virtual FrameCommand *dup() const {return new FrameCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getDataSequenceNumber() const;
    virtual void setDataSequenceNumber(int dataSequenceNumber);
    virtual int getSourcePanID() const;
    virtual void setSourcePanID(int sourcePanID);
    virtual int getDestinationPanID() const;
    virtual void setDestinationPanID(int destinationPanID);
    virtual int getSourceMacAddress() const;
    virtual void setSourceMacAddress(int sourceMacAddress);
    virtual int getDestinationMacAddress() const;
    virtual void setDestinationMacAddress(int destinationMacAddress);
    virtual int getCommandType() const;
    virtual void setCommandType(int commandType);
};

inline void doPacking(cCommBuffer *b, FrameCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FrameCommand& obj) {obj.parsimUnpack(b);}

} // namespace wsn_energy

#endif // ifndef _WSN_ENERGY_FRAME_M_H_

